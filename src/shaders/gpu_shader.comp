#version 430

// Structures
struct Camera {
    vec3 Position;
    float aspectRatio;

    vec3 Front;
	float padding2;

    vec3 Up;
    float padding3;

    vec3 Right;
    float padding4;

    float fov;
    vec3 padding5;
};

struct Light {
    vec3 position;
    float padding1;

    vec3 color;
    float padding2;
};

struct Material {
    vec3 color;
    float fresnelStrength;

    float ambientStrength;
    float diffuseStrength;
    float specularStrength;
    int shininess;
};

struct Shape {
    int type; // 0 for Sphere, 1 for Plane, 2 for Wall, 3 for Triangle
    vec3 padding;

    Material material;

    vec3 sphereCenter; 
    float sphereRadius;

    vec3 planeNormal;  
    float planeD;

    vec3 wallStart;
    float wallWidth;

    float wallHeight;
	vec3 padding1;

    vec3 triP1;
    float padding2;
    vec3 triP2;
    float padding3;
    vec3 triP3;
    float padding4;
};
vec3 getNormalFromShape(Shape shape, vec3 point){
    if (shape.type == 0){
        return normalize(point - shape.sphereCenter);
    }
    else if (shape.type == 1 || shape.type == 2 || shape.type == 3){
       return shape.planeNormal; 
    }
};

// Ray
struct Ray{
    vec3 start;
    vec3 dir;
};

// Intersection
const uint NONE = 0;
const uint INNER = 1;
const uint OUTER = 2;
struct Intersection{
    uint intersect_type;
    vec3 hit_point;
};


///////////////////////////////////////////////////////////////////////////////////
// Inputs
layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D imgOutput;
layout(std430, binding = 1) buffer LightBuffer{
    Light light;
};
layout(std430, binding = 2) buffer CameraBuffer{
    Camera camera;
};
layout(std430, binding = 3) buffer ShapesBuffer{
    Shape shapes[];
};

uniform vec2 screenRes;
uniform int maxBounces;
uniform bool useFresnel;
uniform bool useMollerTrumbore;

///////////////////////////////////////////////////////////////////////////////////
// Functions
vec3 getPointFromRay(Ray ray, float t){
    return ray.start + t*ray.dir;
};
Ray getRay(Camera cam, float ndcX, float ndcY){
    float imagePlaneHeight = 2. * tan(radians(cam.fov/2.));
    float imagePlaneWidth = imagePlaneHeight * cam.aspectRatio;

    vec3 imagePlanePoint = cam.Position + cam.Front + (ndcX * imagePlaneWidth / 2.0f) * cam.Right + (ndcY * imagePlaneHeight / 2.0f) * cam.Up;

    vec3 rayDir = normalize(imagePlanePoint - cam.Position);

    Ray ray;
    ray.start = cam.Position;
    ray.dir = rayDir;

    return ray;
};

Intersection getIntersectionTriangle_MollerTrumbore(Shape shape, Ray ray){
    Intersection intersection;
    intersection.intersect_type = NONE;
    vec3 edge1 = shape.triP2 - shape.triP1;
    vec3 edge2 = shape.triP3 - shape.triP1;
    vec3 h = cross(ray.dir, edge2);
    float a = dot(edge1,h);

    if (abs(a) < 1e-5) return intersection;
    float f = 1.0/a;
    vec3 s = ray.start - shape.triP1;
    float u = f*dot(s,h);
    if (u<0 || u>1) return intersection;

    vec3 q = cross(s, edge1);
    float v = f*dot(ray.dir, q);
    if (v<0 || u+v>1) return intersection;

    float t = f*dot(edge2,q);
    if (t>0){
        intersection.intersect_type = INNER;
        intersection.hit_point = getPointFromRay(ray, t);
    }

    return intersection;
};
Intersection getIntersectionTriangle_Barycentric(Shape shape, Ray ray){
        Intersection intersection;
        intersection.intersect_type = NONE;
        
        // Base intersection with plane
        float np = dot(shape.planeNormal, ray.dir);
        if (np == 0) return intersection;

        float t = -(shape.planeD + dot(shape.planeNormal, ray.start)) / np;
        if (t > 0){
            intersection.intersect_type = (np > 0) ? INNER : OUTER;
            intersection.hit_point = getPointFromRay(ray, t);
        }
        else {
            return intersection;
        }

        vec3 hitPoint = intersection.hit_point;

        // Compute vectors for edges and point-to-vertex
        vec3 edge1 = shape.triP2 - shape.triP1;
        vec3 edge2 = shape.triP3 - shape.triP1;
        vec3 toPoint = hitPoint - shape.triP1;

        // Barycentric coordinates
        float d00 = dot(edge1, edge1);
        float d01 = dot(edge1, edge2);
        float d11 = dot(edge2, edge2);
        float d20 = dot(toPoint, edge1);
        float d21 = dot(toPoint, edge2);
        
        float denom = d00 * d11 - d01 * d01;
        float v = (d11 * d20 - d01 * d21) / denom;
        float w = (d00 * d21 - d01 * d20) / denom;
        float u = 1.0 - v - w;

        // Check if the point lies inside the triangle
        if (u < 0 || v < 0 || w < 0) {
            intersection.intersect_type = NONE;
        }

        return intersection;
};

Intersection get_intersection(Shape shape, Ray ray){
    Intersection intersection;
    intersection.intersect_type = NONE;

    if (shape.type == 0){ // Sphere
        vec3 start = ray.start;
        vec3 dir = ray.dir;

        float aa = dot(dir,dir);
        float bb = 2 * (dot(dir, start-shape.sphereCenter));
        float cc = dot(start-shape.sphereCenter, start-shape.sphereCenter) - shape.sphereRadius * shape.sphereRadius;
        float D = bb * bb - 4 * aa * cc;
        
        if (D > 0){
            float sD = sqrt(D);
            float t1 = (-bb - sD) / (2 * aa);
            if (t1 > 0) {
                intersection.intersect_type = INNER;
                intersection.hit_point = getPointFromRay(ray, t1);
                return intersection;
            }
            float t2 = (-bb + sD) / (2 * aa);
            if (t2 > 0) {
                intersection.intersect_type = OUTER;
                intersection.hit_point = getPointFromRay(ray, t2);
                return intersection;
            }
        }
    }
    else if (shape.type == 1){ // Plane
        float np = dot(shape.planeNormal, ray.dir);
        if (np == 0) return intersection;

        float t = -(shape.planeD + dot(shape.planeNormal, ray.start)) / np;
        if (t > 0){
            intersection.intersect_type = (np > 0) ? INNER : OUTER;
            intersection.hit_point = getPointFromRay(ray, t);
        }
        else {
            return intersection;
        }
    }
    else if (shape.type == 2){ // Wall
        // Base intersection
        float np = dot(shape.planeNormal, ray.dir);
        if (np == 0) return intersection;

        float t = -(shape.planeD + dot(shape.planeNormal, ray.start)) / np;
        if (t > 0){
            intersection.intersect_type = (np > 0) ? INNER : OUTER;
            intersection.hit_point = getPointFromRay(ray, t);
        }
        else {
            return intersection;
        }

        vec3 hitPoint = intersection.hit_point;

        vec3 u = normalize(cross(shape.planeNormal, vec3(0,1,0)));
        if (length(u) < 1e-4) u = normalize(cross(shape.planeNormal, vec3(1,0,0)));
        vec3 v = normalize(cross(shape.planeNormal, u));

        vec3 localPoint = hitPoint - shape.wallStart;
        float uProj = dot(localPoint, u);
        float vProj = dot(localPoint, v);

        if (uProj < 0 || uProj > shape.wallWidth || vProj < 0 || vProj > shape.wallHeight)
            intersection.intersect_type = NONE;

    }
    else if (shape.type == 3){ // Triangle

        if (useMollerTrumbore) {
            intersection = getIntersectionTriangle_MollerTrumbore(shape, ray);
        }
        else {
            intersection = getIntersectionTriangle_Barycentric(shape, ray);
        }
    }

    return intersection;
};

// Phong shading
vec3 phong(vec3 point, vec3 normal, vec3 viewDir, Light light, Material mat){
    // Material properties
	float ambientStrength = mat.ambientStrength;
	float diffuseStrength = mat.diffuseStrength;
	float specularStrength = mat.specularStrength;
	int shininess = mat.shininess;

    // Distance-based light attenuation
    float distToLight = distance(light.position, point);
    vec3 lightColor = light.color / (distToLight);

    // Ambient component
	vec3 ambient = ambientStrength * lightColor;

    // Diffuse component
	vec3 lightDir = normalize(light.position - point);
	float diff = max(dot(normal, lightDir), 0.0);
	vec3 diffuse = diffuseStrength * diff * lightColor;

    // Specular component
	vec3 specular = vec3(0);
	if (diff > 0.) {
		vec3 reflectDir = reflect(-lightDir, normal);
		float spec = pow(max(dot(viewDir, reflectDir), 0.0), shininess);
		specular = specularStrength * spec * lightColor;
	}

    // Combine results
	vec3 result = (ambient + diffuse + specular) * mat.color;
	return result;
}; 



///////////////////////////////////////////////////////////////////////////////////
void main() {
    ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);

    vec3 bgColor = mix(vec3(0.5, 0.7, 1.0), vec3(0.0), texelCoord.y / screenRes.y); // Gradient  
    vec4 value = vec4(bgColor, 1.0); // background color

    // Get ray from camera
    Ray ray = getRay(
                camera, 
                2. * texelCoord.x / screenRes.x - 1, 
                1. - 2. * texelCoord.y / screenRes.y);
    

    
    vec3 accumulatedColor = vec3(0);
    vec3 attenuation = vec3(1);

    for (int depth=0; depth<maxBounces; ++depth){
        // Just high number, I dont want to divide by 0 to achieve infinity
        float closestDist = 10000;

        bool hitSomething = false;
        vec3 hitColor = bgColor;
        Material hitMaterial;
        vec3 hitPoint;
        vec3 hitNormal;

        // Closest intersection
        for (int i=0; i<shapes.length(); ++i){
            // Trace ray
            Intersection s_hit = get_intersection(shapes[i], ray);
            if (s_hit.intersect_type == INNER){
            
                float dist = distance(ray.start, s_hit.hit_point);
                if (dist < closestDist) {
                    closestDist = dist;
                    hitSomething = true;

                    hitPoint = s_hit.hit_point;
                    hitNormal = getNormalFromShape(shapes[i], hitPoint);
                    hitMaterial = shapes[i].material;
                    hitColor = shapes[i].material.color;
                }
            }
        }

        if (!hitSomething){
            // Nothing hit, add background color
            accumulatedColor += attenuation * bgColor; // not necessary imo
            break;
        }

        // Shadow ray
        bool inShadow = false;
        Ray shadowRay;
        shadowRay.start = hitPoint + hitNormal * 1e-4;
        shadowRay.dir = normalize(light.position - hitPoint);

        // Shadow check
        for (int i=0; i<shapes.length(); ++i){
            Intersection shadowHit = get_intersection(shapes[i], shadowRay);

            if (shadowHit.intersect_type == INNER) {
                float lightDist = distance(light.position, hitPoint);
                float hitDist = distance(shadowRay.start, shadowHit.hit_point);
                if(hitDist < lightDist){
                    inShadow = true;
                    break;
                }
            }
        }

        // Compute color of the hitPoint
        vec3 phongColor = phong(
                                hitPoint, 
                                hitNormal, 
                                ray.dir, 
                                light, 
                                hitMaterial);
        
        // If in shadow, make color darker
        if (inShadow) phongColor *= 0.3;

        accumulatedColor += attenuation * phongColor;

        if (hitMaterial.specularStrength > 0) {
            // Generate reflection ray
            vec3 reflectDir = reflect(ray.dir, hitNormal);
            ray.start = hitPoint + hitNormal * 1e-4; // Offset to avoid selfintersection
            ray.dir = reflectDir;

            if (useFresnel){
                float fresnel = pow(1.0 - max(dot(-ray.dir, hitNormal), 0.0), 5.0);
                fresnel = clamp(fresnel, 0.0, 0.8);

                // Blend attenuation
                float reflectionWeight = hitMaterial.fresnelStrength * fresnel;
                float materialWeight = 1.0 - reflectionWeight;

                attenuation *= mix(hitColor, vec3(1.0), reflectionWeight);
                accumulatedColor += materialWeight * hitColor * phongColor;
            }
            else
                attenuation *= hitMaterial.specularStrength;
            
        }
        else break;
    }

    value.xyz = accumulatedColor;

    imageStore(imgOutput, texelCoord, value);
}
