#version 430

// Structures
struct Camera {
    vec3 Position;
    float aspectRatio;

    vec3 Front;
	float padding2;

    vec3 Up;
    float padding3;

    vec3 Right;
    float padding4;

    float fov;
    vec3 padding5;
};

struct Light {
    vec3 position;
    float padding1;

    vec3 color;
    float padding2;
};

struct Material {
    float ambientStrength;
    float diffuseStrength;
    float specularStrength;
    int shininess;
};

struct Shape {
    int type; // 0 for Sphere, 1 for Plane
    vec3 color;

    Material material;

    vec3 sphereCenter; 
    float sphereRadius;

    vec3 planeNormal;  
    float planeD;
};
vec3 getNormalFromShape(Shape shape, vec3 point){
    if (shape.type == 0){
        return normalize(point - shape.sphereCenter);
    }
    else if (shape.type == 1){
       return shape.planeNormal; 
    }
};

// Ray
struct Ray{
    vec3 start;
    vec3 dir;
};
vec3 getPointFromRay(Ray ray, float t){
    return ray.start + t*ray.dir;
};
Ray getRay(Camera cam, float ndcX, float ndcY){
    float imagePlaneHeight = 2. * tan(radians(cam.fov/2.));
    float imagePlaneWidth = imagePlaneHeight * cam.aspectRatio;

    vec3 imagePlanePoint = cam.Position + cam.Front + (ndcX * imagePlaneWidth / 2.0f) * cam.Right + (ndcY * imagePlaneHeight / 2.0f) * cam.Up;

    vec3 rayDir = normalize(imagePlanePoint - cam.Position);

    Ray ray;
    ray.start = cam.Position;
    ray.dir = rayDir;

    return ray;
};

// Intersection
const uint NONE = 0;
const uint INNER = 1;
const uint OUTER = 2;
struct Intersection{
    uint intersect_type;
    vec3 hit_point;
};
Intersection get_intersection(Shape shape, Ray ray){
    Intersection intersection;
    intersection.intersect_type = NONE;

    if (shape.type == 0){
        vec3 start = ray.start;
        vec3 dir = ray.dir;

        float aa = dot(dir,dir);
        float bb = 2 * (dot(dir, start-shape.sphereCenter));
        float cc = dot(start-shape.sphereCenter, start-shape.sphereCenter) - shape.sphereRadius * shape.sphereRadius;
        float D = bb * bb - 4 * aa * cc;
        
        if (D > 0){
            float sD = sqrt(D);
            float t1 = (-bb - sD) / (2 * aa);
            if (t1 > 0) {
                intersection.intersect_type = INNER;
                intersection.hit_point = getPointFromRay(ray, t1);
                return intersection;
            }
            float t2 = (-bb + sD) / (2 * aa);
            if (t2 > 0) {
                intersection.intersect_type = OUTER;
                intersection.hit_point = getPointFromRay(ray, t2);
                return intersection;
            }
        }
    }
    else if (shape.type == 1){
        float np = dot(shape.planeNormal, ray.dir);
        if (np == 0) return intersection;

        float t = -(shape.planeD + dot(shape.planeNormal, ray.start)) / np;
        if (t > 0){
            intersection.intersect_type = (np > 0) ? INNER : OUTER;
            intersection.hit_point = getPointFromRay(ray, t);
        }
        else {
            return intersection;
        }
    }

    return intersection;
};

// Phong shading
vec3 phong(vec3 point, vec3 normal, vec3 viewDir, vec3 objectColor, Light light, Material mat){
    // Material properties
	float ambientStrength = mat.ambientStrength;
	float diffuseStrength = mat.diffuseStrength;
	float specularStrength = mat.specularStrength;
	int shininess = mat.shininess;

    // Distance-based light attenuation
    float distToLight = distance(light.position, point);
    vec3 lightColor = light.color / (distToLight);

    // Ambient component
	vec3 ambient = ambientStrength * lightColor;

    // Diffuse component
	vec3 lightDir = normalize(light.position - point);
	float diff = max(dot(normal, lightDir), 0.0);
	vec3 diffuse = diffuseStrength * diff * lightColor;

    // Specular component
	vec3 specular = vec3(0);
	if (diff > 0.) {
		vec3 reflectDir = reflect(-lightDir, normal);
		float spec = pow(max(dot(viewDir, reflectDir), 0.0), shininess);
		specular = specularStrength * spec * lightColor;
	}

    // Combine results
	vec3 result = (ambient + diffuse + specular) * objectColor;
	return result;
}; 


layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D imgOutput;
layout(std430, binding = 1) buffer LightBuffer{
    Light light;
};
layout(std430, binding = 2) buffer CameraBuffer{
    Camera camera;
};
layout(std430, binding = 3) buffer ShapesBuffer{
    Shape shapes[];
};

uniform vec2 screenRes;
uniform int maxBounces;
uniform bool useFresnel;

void main() {
    ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);

    vec3 bgColor = mix(vec3(0.5, 0.7, 1.0), vec3(0.0), texelCoord.y / screenRes.y); // Gradient  
    vec4 value = vec4(bgColor, 1.0); // background color

    // Get ray from camera
    Ray ray = getRay(
                camera, 
                2. * texelCoord.x / screenRes.x - 1, 
                1. - 2. * texelCoord.y / screenRes.y);
    

    // Just high number, I dont want to divide by 0 to achieve infinity
    float closestDist = 10000;

    vec3 accumulatedColor = vec3(0);
    vec3 attenuation = vec3(1); // TODO: vec3 ?

    for (int depth=0; depth<maxBounces; ++depth){
        bool hitSomething = false;
        vec3 hitColor = bgColor;
        Material hitMaterial;
        vec3 hitPoint;
        vec3 hitNormal;

        // Closest intersection
        for (int i=0; i<shapes.length(); ++i){
            // Trace ray
            Intersection s_hit = get_intersection(shapes[i], ray);
            if (s_hit.intersect_type == INNER){
            
                float dist = distance(ray.start, s_hit.hit_point);
                if (dist < closestDist) {
                    closestDist = dist;
                    hitSomething = true;

                    hitPoint = s_hit.hit_point;
                    hitNormal = getNormalFromShape(shapes[i], hitPoint);
                    hitMaterial = shapes[i].material;
                    hitColor = shapes[i].color;
                }
            }
        }

        if (!hitSomething){
            // Nothing hit, add background color
            accumulatedColor += attenuation * bgColor; // not necessary imo
            break;
        }

        // Shadow ray
        bool inShadow = false;
        Ray shadowRay;
        shadowRay.start = hitPoint + hitNormal * 1e-4;
        shadowRay.dir = normalize(light.position - hitPoint);

        // Shadow check
        for (int i=0; i<shapes.length(); ++i){
            Intersection shadowHit = get_intersection(shapes[i], shadowRay);

            if (shadowHit.intersect_type == INNER) {
                float lightDist = distance(light.position, hitPoint);
                float hitDist = distance(shadowRay.start, shadowHit.hit_point);
                if(hitDist < lightDist){
                    inShadow = true;
                    break;
                }
            }
        }

        // Compute color of the hitPoint, if NOT in shadow
        vec3 phongColor = vec3(0);
        if (!inShadow)
            phongColor = phong(
                                hitPoint, 
                                hitNormal, 
                                ray.dir, 
                                hitColor, 
                                light, 
                                hitMaterial);

        accumulatedColor = attenuation * phongColor;

        if (hitMaterial.specularStrength > 0) {
            // Generate reflection ray
            vec3 reflectDir = reflect(ray.dir, hitNormal);
            ray.start = hitPoint + hitNormal * 1e-4; // Offset to avoid selfintersection
            ray.dir = reflectDir;

            if (useFresnel){
                float fresnel = pow(1.0 - max(dot(-ray.dir, hitNormal), 0.0), 5.0);
                attenuation *= mix(vec3(1.0), hitColor, fresnel);
            }
            else
                attenuation *= hitMaterial.specularStrength;
            
        }
        else break;
    }

    value.xyz = accumulatedColor;

    imageStore(imgOutput, texelCoord, value);
}
